<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>D1 Read Replicas - Cloudflare</title>
    <link rel="stylesheet" href="global.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/themes/prism-tomorrow.min.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-typescript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-bash.min.js"></script>
</head>
<body>
    <header class="header">
        <div class="header-content">
            <div class="logo">
                <img src="cloudflare.svg" alt="Cloudflare">
            </div>
            <div class="auth-buttons">
                <button class="sign-in">Sign In</button>
                <button class="sign-up">Sign Up</button>
            </div>
        </div>
    </header>

    <main class="main-content">
        <div class="hero-section">
            <div class="breadcrumb">> All New</div>
            <h1>D1 Read Replicas</h1>
            <p class="description">
                Read replicas let you query data from servers closer to you, which means faster response times and less waiting.

                Speed up your queries in just a few clicks.
            </p>
            <div class="time-savings">
                <div class="comparison">Queries are <span class="highlight savings-value">&nbsp;0ms&nbsp;</span> faster with your closest replica</div>
                <div class="detail">Compared to querying the primary in Sydney, Australia (<span class="au-latency">-</span>ms)</div>
            </div>

            <div class="controls" style="display: none;">
                <button class="write-button" id="writeButton">Get Started</button>
                <span class="last-write" id="lastWrite"></span>
            </div>
        </div>

        <div class="content-layout">
            <div class="regions-list" id="regionsList">
                <!-- Region cards will be populated by JavaScript -->
            </div>
            <div class="globe-container" id="globeContainer"></div>
        </div>
        
        <div class="docs-section">
            <div class="docs-block">
                <h2>Enable Replication</h2>
                <p>Today you can create new or enable existing D1 databases with global read replication. Requests will be routed to the nearest replica and benefit from the fastest read speeds.</p>
                
                <div class="code-block">
                    <div class="code-header">
                        <span>Enable Read replication</span>
                        <button class="copy-button" onclick="copyCode(this)">
                            <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                                <path d="M13 5H7C6.45 5 6 5.45 6 6v7c0 .55.45 1 1 1h6c.55 0 1-.45 1-1V6c0-.55-.45-1-1-1z" stroke="currentColor" stroke-width="1.5"/>
                                <path d="M3 11H2c-.55 0-1-.45-1-1V3c0-.55.45-1 1-1h6c.55 0 1 .45 1 1v1" stroke="currentColor" stroke-width="1.5"/>
                            </svg>
                            <span>Copy</span>
                        </button>
                    </div>
                    <pre><code>curl -X PUT <span class="string">"https://api.cloudflare.com/client/v4/accounts/{account_id}/d1/database/{database_id}"</span> \
    -H <span class="string">"Authorization: Bearer $TOKEN"</span> \
    -H <span class="string">"Content-Type: application/json"</span> \
    -d <span class="string">'{"read_replication": {"mode": "auto"}}'</span></code></pre>
                </div>
            </div>

            <div class="docs-block">
                <h2>Read Consistency</h2>
                <p>D1's Session API allows you to maintain read consistency across multiple queries. By storing and reusing the session bookmark, you can ensure that subsequent reads see all changes from previous operations. This is particularly useful when you need to maintain a consistent view of the database across multiple requests.</p>
                
                <div class="code-block">
                    <div class="code-header">
                        <span>Session API Example</span>
                        <button class="copy-button" onclick="copyCode(this)">
                            <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                                <path d="M13 5H7C6.45 5 6 5.45 6 6v7c0 .55.45 1 1 1h6c.55 0 1-.45 1-1V6c0-.55-.45-1-1-1z" stroke="currentColor" stroke-width="1.5"/>
                                <path d="M3 11H2c-.55 0-1-.45-1-1V3c0-.55.45-1 1-1h6c.55 0 1 .45 1 1v1" stroke="currentColor" stroke-width="1.5"/>
                            </svg>
                            <span>Copy</span>
                        </button>
                    </div>
                    <pre><code><span class="comment">// Retrieve bookmark from previous session stored in HTTP header</span>
<span class="keyword">const</span> <span class="variable">bookmark</span> = <span class="variable">request</span>.<span class="property">headers</span>.<span class="function">get</span>(<span class="string">'x-d1-bookmark'</span>) ?? <span class="string">'first-unconstrained'</span>;
<span class="keyword">const</span> <span class="variable">session</span> = <span class="variable">env</span>.<span class="property">DB</span>.<span class="function">withSession</span>(<span class="variable">bookmark</span>)

<span class="keyword">await</span> <span class="variable">session</span>
    .<span class="function">prepare</span>(<span class="string">"INSERT INTO Orders VALUES (?, ?, ?) ON CONFLICT DO NOTHING"</span>)
    .<span class="function">bind</span>(<span class="variable">order</span>.<span class="property">customerId</span>, <span class="variable">order</span>.<span class="property">orderId</span>, <span class="variable">order</span>.<span class="property">quantity</span>)
    .<span class="function">run</span>();

<span class="keyword">const</span> <span class="variable">result</span> = <span class="keyword">await</span> <span class="variable">session</span>.<span class="function">prepare</span>(<span class="string">"SELECT * FROM Orders"</span>).<span class="function">all</span>();

<span class="comment">// Store bookmark for a future session</span>
<span class="variable">response</span>.<span class="property">headers</span>.<span class="function">set</span>(<span class="string">'x-d1-bookmark'</span>, <span class="variable">session</span>.<span class="function">getBookmark</span>() ?? <span class="string">""</span>)</code></pre>
                </div>
            </div>
        </div>

        <!-- Hidden container for mobile globes -->
        <div id="mobileGlobeContainer" style="position: absolute; pointer-events: none;"></div>
    </main>
    <script>
        function copyCode(button) {
            const codeBlock = button.closest('.code-block').querySelector('code');
            navigator.clipboard.writeText(codeBlock.textContent);
            
            const span = button.querySelector('span');
            const originalText = span.textContent;
            span.textContent = 'Copied!';
            button.classList.add('copied');
            
            setTimeout(() => {
                span.textContent = originalText;
                button.classList.remove('copied');
            }, 2000);
        }
    </script>

    <script type="module">
        import { Globe } from './js/Globe.js';

        const API_BASE = 'https://replication-regions.brayden-b8b.workers.dev';
        const writeButton = document.getElementById('writeButton');
        const lastWrite = document.getElementById('lastWrite');
        const regionsList = document.getElementById('regionsList');
        const globeContainer = document.getElementById('globeContainer');
        let lastWriteTime = null;
        let regionData = {};
        let latencyHistory = {};
        let globeInstance = null;
        let updateInterval;
        let currentRegion = null;
        let mobileGlobeInstance = null;
        let regionGlobeViews = {};
        let isAnimating = false;
        let currentAnimationFrame = null;

        // Fetch locations data
        async function loadLocations() {
            try {
                const response = await fetch('/locations.json');
                const data = await response.json();
                regionData = data;
            } catch (error) {
                console.error('Error loading locations:', error);
                regionData = {};
            }
        }

        async function performWrite(renderResults = true) {
            writeButton.disabled = true;
            const regions = ['wnam', 'enam', 'weur', 'eeur', 'apac', 'oc'];
            lastWriteTime = new Date();
            // lastWrite.textContent = `Last write: ${lastWriteTime.toLocaleTimeString()}`;

            try {
                const requests = regions.map(region => {
                    const startTime = performance.now();
                    return fetch(`${API_BASE}`, {
                        method: 'POST',
                        mode: 'cors',
                        headers: {
                            'Accept': '*/*',
                            'Content-Type': 'application/json',
                        },
                        credentials: 'omit',
                        body: JSON.stringify({ region })
                    })
                    .then(async response => {
                        const endTime = performance.now();
                        if (!response.ok) throw new Error(`Network response was not ok for ${region}`);
                        const data = await response.json();
                        const latency = Math.round(endTime - startTime - data.subtract);
                        
                        if (!latencyHistory[data.colo]) {
                            latencyHistory[data.colo] = [];
                        }
                        latencyHistory[data.colo].push(latency);
                        
                        return {
                            region: region.toUpperCase(),
                            latency: latency,
                            colo: data.colo
                        };
                    });
                });

                const results = await Promise.all(requests);
                window.latencyResults = results;
                if (renderResults) {
                    updateCards();
                    updateTimeSavings(results);
                }
            } catch (error) {
                console.error('Error performing writes:', error);
            } finally {
                writeButton.disabled = false;
            }
        }

        function calculateStats(latencies) {
            if (!latencies || latencies.length === 0) return { mean: '-', median: '-', min: '-', max: '-' };
            
            const mean = Math.round(latencies.reduce((a, b) => a + b, 0) / latencies.length);
            const sorted = [...latencies].sort((a, b) => a - b);
            const median = Math.round(sorted[Math.floor(sorted.length / 2)]);
            const min = Math.min(...latencies);
            const max = Math.max(...latencies);
            
            return { mean, median, min, max };
        }

        function getLatencyClass(value) {
            if (value === '-') return '';
            if (value < 100) return 'latency-good';
            if (value < 200) return 'latency-medium';
            return 'latency-poor';
        }

        // Initialize mobile globe and pre-render all region views
        async function initializeMobileGlobes() {
            if (!mobileGlobeInstance) {
                const container = document.createElement('div');
                mobileGlobeInstance = new Globe(container, 160, 80);
                mobileGlobeInstance.stopAnimation(); // Stop animation immediately
                
                // Wait for texture to load
                await new Promise(resolve => {
                    const checkTexture = () => {
                        if (mobileGlobeInstance.texture) {
                            resolve();
                        } else {
                            setTimeout(checkTexture, 50);
                        }
                    };
                    checkTexture();
                });
                
                // Pre-render each region's view
                const regionAngles = {
                    'wnam': { x: -Math.PI / 2.2, y: Math.PI * 1.15 + Math.PI / 2 },
                    'enam': { x: -Math.PI / 2.2, y: Math.PI * 1.15 + Math.PI },
                    'weur': { x: -Math.PI / 2.2, y: Math.PI * 1.15 + Math.PI * 1.5 },
                    'eeur': { x: -Math.PI / 2.2, y: Math.PI * 1.15 + Math.PI * 2 },
                    'apac': { x: -Math.PI / 2.2, y: Math.PI * 1.15 + Math.PI * 2.5 },
                    'oc': { x: -Math.PI / 2.2, y: Math.PI * 1.15 + Math.PI * 3 }
                };

                // Generate and store ASCII for each region
                Object.entries(regionAngles).forEach(([region, angles]) => {
                    mobileGlobeInstance.angleX = angles.x;
                    mobileGlobeInstance.angleY = angles.y;
                    mobileGlobeInstance.angleZ = 0;
                    const ascii = mobileGlobeInstance.render();
                    regionGlobeViews[region] = `<pre>${ascii}</pre>`;
                });
            }
        }

        async function updateCards() {
            const results = window.latencyResults || [];
            
            // Initialize globes if needed
            if (!globeInstance) {
                globeInstance = new Globe(globeContainer, 160, 80);
                globeInstance.angleX = -Math.PI / 2.2;
                globeInstance.angleY = Math.PI * 1.15;
                globeInstance.angleZ = 0;
                globeInstance.render();
            }
            
            // Initialize mobile globes if needed
            await initializeMobileGlobes();
            
            // Find the fastest region
            const fastestLatency = Math.min(...results.map(r => r.latency));
            
            regionsList.innerHTML = results.map(result => {
                const location = regionData.find(loc => loc.iata === result.colo);
                const locationName = location ? `${location.city}, ${location.cca2}, ${location.region}` : result.colo;
                const stats = calculateStats(latencyHistory[result.colo]);
                const isFastest = result.latency === fastestLatency;
                const regionKey = result.region.toLowerCase();

                return `
                    <div class="region-card ${isFastest ? 'fastest' : ''}" 
                         data-region="${regionKey}"
                         onmouseenter="handleCardHover('${regionKey}')">
                        <div class="card-header">
                            <span class="region-code">${result.colo}</span>
                            <h3>${locationName}</h3>
                        </div>
                        <div class="card-stats">
                            <div class="stat">
                                <span class="stat-label">Mean</span>
                                <span class="stat-value ${getLatencyClass(stats.mean)}">${stats.mean} ms</span>
                            </div>
                            <div class="stat">
                                <span class="stat-label">Median</span>
                                <span class="stat-value ${getLatencyClass(stats.median)}">${stats.median} ms</span>
                            </div>
                        </div>
                        <div class="mobile-globe">
                            ${regionGlobeViews[regionKey] || ''}
                        </div>
                    </div>

                `;
            }).join('');
        }

        // Handle card hover to rotate globe
        window.handleCardHover = function(region) {
            if (globeInstance && region !== currentRegion) {
                currentRegion = region;
                
                const regionAngles = {
                    'wnam': { x: -Math.PI / 2.2, y: Math.PI * 1.15 + Math.PI / 2 },
                    'enam': { x: -Math.PI / 2.2, y: Math.PI * 1.15 + Math.PI },
                    'weur': { x: -Math.PI / 2.2, y: Math.PI * 1.15 + Math.PI * 1.5 },
                    'eeur': { x: -Math.PI / 2.2, y: Math.PI * 1.15 + Math.PI * 2 },
                    'apac': { x: -Math.PI / 2.2, y: Math.PI * 1.15 + Math.PI * 2.5 },
                    'oc': { x: -Math.PI / 2.2, y: Math.PI * 1.15 + Math.PI * 3 }
                };

                const angles = regionAngles[region];
                if (angles) {
                    globeInstance.setTargetRotation(angles.x, angles.y);
                }
            }
        };

        // Add mouseout handler to reset current region when not hovering any card
        document.addEventListener('DOMContentLoaded', () => {
            const regionsList = document.getElementById('regionsList');
            regionsList.addEventListener('mouseleave', () => {
                currentRegion = null;
                if (globeInstance) {
                    globeInstance.setTargetRotation(-Math.PI / 2.2, Math.PI * 1.15);
                }

            });
        });

        // Function to update time savings display
        function updateTimeSavings(results) {
            if (!results || results.length === 0) return;
            
            // Find Australia's latency (OC region)
            const auResult = results.find(r => r.region === 'OC');
            const auLatency = auResult ? auResult.latency : 0;
            
            // Find fastest latency
            const fastestLatency = Math.min(...results.map(r => r.latency));
            
            // Calculate time savings
            const savings = auLatency - fastestLatency;
            
            // Update the display
            const savingsElement = document.querySelector('.savings-value');
            const auLatencyElement = document.querySelector('.au-latency');
            const timeSavingsElement = document.querySelector('.time-savings');
            
            if (savingsElement && auLatencyElement) {
                savingsElement.textContent = `${savings}ms`;
                auLatencyElement.textContent = auLatency;
                
                // Show the element with animation
                timeSavingsElement.classList.add('visible');
            }
        }

        // Initialize
        loadLocations().then(async () => {
            writeButton.addEventListener('click', () => performWrite(true));
            latencyHistory = {};
            await performWrite(false);
            
            // Set up automatic refresh every 5 seconds
            updateInterval = setInterval(() => {
                performWrite(true);
            }, 5000);
            
            setTimeout(() => {
                latencyHistory = {};

                performWrite(true);
                
                // Set up periodic writes
                let writeInterval;
                
                function startWrites() {
                    writeInterval = setInterval(() => performWrite(true), 5000);
                }
                
                function stopWrites() {
                    clearInterval(writeInterval);
                }
                
                // Handle window focus/blur
                window.addEventListener('focus', () => {
                    performWrite(true);  // Immediate write
                    startWrites();       // Start interval
                });
                
                window.addEventListener('blur', () => {
                    stopWrites();
                });
                
                // Start writes if window is focused
                if (document.hasFocus()) {
                    startWrites();
                }
            }, 100);
        });

        // Cleanup interval when page unloads
        window.addEventListener('unload', () => {
            if (updateInterval) {
                clearInterval(updateInterval);

            }
        });
    </script>
</body>
</html> 