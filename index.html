<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>D1 Read Replicas - Cloudflare</title>
    <link rel="stylesheet" href="global.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
</head>
<body>
    <header class="header">
        <div class="header-content">
            <div class="logo">
                <img src="cloudflare.svg" alt="Cloudflare">
            </div>
            <div class="auth-buttons">
                <button class="sign-in">Sign In</button>
                <button class="sign-up">Sign Up</button>
            </div>
        </div>
    </header>

    <main class="main-content">
        <div class="hero-section">
            <div class="breadcrumb">> All New</div>
            <h1>D1 Read Replicas</h1>
            <p class="description">
                Read replicas let you query data from servers closer to you, which means faster response times and less waiting.

                Speed up your queries in just a few clicks.
            </p>
            <div class="time-savings">
                <div class="comparison">Queries are <span class="highlight savings-value">&nbsp; 0ms</span> faster with your closest replica</div>
                <div class="detail">Compared to querying the primary in <span class="slowest-location">the furthest region</span> (<span class="slowest-latency">-</span>ms)</div>
            </div>

            <div class="controls" style="display: none;">
                <button class="write-button" id="writeButton">Get Started</button>
                <span class="last-write" id="lastWrite"></span>
            </div>
        </div>

        <div class="content-layout">
            <div class="regions-list" id="regionsList">
                <!-- Region cards will be populated by JavaScript -->
            </div>
            <div class="globe-container" id="globeContainer"></div>
        </div>
        
        <div class="docs-section">
            <div class="docs-block">
                <h2>Enable Replication</h2>
                <p>Today you can create new or enable existing D1 databases with global read replication. Requests will be routed to the nearest replica and benefit from the fastest read speeds.</p>
                
                <div class="code-block">
                    <div class="code-header">
                        <span>Enable Read replication</span>
                        <button class="copy-button" onclick="copyCode(this)">
                            <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                                <path d="M13 5H7C6.45 5 6 5.45 6 6v7c0 .55.45 1 1 1h6c.55 0 1-.45 1-1V6c0-.55-.45-1-1-1z" stroke="currentColor" stroke-width="1.5"/>
                                <path d="M3 11H2c-.55 0-1-.45-1-1V3c0-.55.45-1 1-1h6c.55 0 1 .45 1 1v1" stroke="currentColor" stroke-width="1.5"/>
                            </svg>
                            <span>Copy</span>
                        </button>
                    </div>
                    <pre><code>curl -X PUT <span class="string">"https://api.cloudflare.com/client/v4/accounts/{account_id}/d1/database/{database_id}"</span> \
    -H <span class="string">"Authorization: Bearer $TOKEN"</span> \
    -H <span class="string">"Content-Type: application/json"</span> \
    -d <span class="string">'{"read_replication": {"mode": "auto"}}'</span></code></pre>
                </div>
            </div>

            <div class="docs-block">
                <h2>Read Consistency</h2>
                <p>D1's Session API allows you to maintain read consistency across multiple queries. By storing and reusing the session bookmark, you can ensure that subsequent reads see all changes from previous operations. This is particularly useful when you need to maintain a consistent view of the database across multiple requests.</p>
                
                <div class="code-block">
                    <div class="code-header">
                        <span>Session API Example</span>
                        <button class="copy-button" onclick="copyCode(this)">
                            <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                                <path d="M13 5H7C6.45 5 6 5.45 6 6v7c0 .55.45 1 1 1h6c.55 0 1-.45 1-1V6c0-.55-.45-1-1-1z" stroke="currentColor" stroke-width="1.5"/>
                                <path d="M3 11H2c-.55 0-1-.45-1-1V3c0-.55.45-1 1-1h6c.55 0 1 .45 1 1v1" stroke="currentColor" stroke-width="1.5"/>
                            </svg>
                            <span>Copy</span>
                        </button>
                    </div>
                    <pre><code><span class="comment">// Retrieve bookmark from previous session stored in HTTP header</span>
<span class="keyword">const</span> <span class="variable">bookmark</span> = <span class="variable">request</span>.<span class="property">headers</span>.<span class="function">get</span>(<span class="string">'x-d1-bookmark'</span>) ?? <span class="string">'first-unconstrained'</span>;
<span class="keyword">const</span> <span class="variable">session</span> = <span class="variable">env</span>.<span class="property">DB</span>.<span class="function">withSession</span>(<span class="variable">bookmark</span>)

<span class="keyword">await</span> <span class="variable">session</span>
    .<span class="function">prepare</span>(<span class="string">"INSERT INTO Orders VALUES (?, ?, ?) ON CONFLICT DO NOTHING"</span>)
    .<span class="function">bind</span>(<span class="variable">order</span>.<span class="property">customerId</span>, <span class="variable">order</span>.<span class="property">orderId</span>, <span class="variable">order</span>.<span class="property">quantity</span>)
    .<span class="function">run</span>();

<span class="keyword">const</span> <span class="variable">result</span> = <span class="keyword">await</span> <span class="variable">session</span>.<span class="function">prepare</span>(<span class="string">"SELECT * FROM Orders"</span>).<span class="function">all</span>();

<span class="comment">// Store bookmark for a future session</span>
<span class="variable">response</span>.<span class="property">headers</span>.<span class="function">set</span>(<span class="string">'x-d1-bookmark'</span>, <span class="variable">session</span>.<span class="function">getBookmark</span>() ?? <span class="string">""</span>)</code></pre>
                </div>
            </div>
        </div>

        <!-- Hidden container for mobile globes -->
        <div id="mobileGlobeContainer" style="position: absolute; pointer-events: none;"></div>
    </main>

    <script>
        function copyCode(button) {
            const codeBlock = button.closest('.code-block').querySelector('code');
            navigator.clipboard.writeText(codeBlock.textContent);
            
            const span = button.querySelector('span');
            const originalText = span.textContent;
            span.textContent = 'Copied!';
            button.classList.add('copied');
            
            setTimeout(() => {
                span.textContent = originalText;
                button.classList.remove('copied');
            }, 2000);
        }
    </script>

    <script type="module">
        import { Globe } from './js/Globe.js';

        const API_BASE = 'https://replication-regions.invisal.workers.dev';
        const writeButton = document.getElementById('writeButton');
        const lastWrite = document.getElementById('lastWrite');
        const regionsList = document.getElementById('regionsList');
        const globeContainer = document.getElementById('globeContainer');
        let lastWriteTime = null;
        let regionData = {};
        let latencyHistory = {};
        let globeInstance = null;
        let updateInterval;
        let currentRegion = null;
        let mobileGlobeInstance = null;
        let regionGlobeViews = {};
        let isAnimating = false;
        let currentAnimationFrame = null;

        // Fetch locations data
        async function loadLocations() {
            try {
                const response = await fetch('/locations.json');
                const data = await response.json();
                regionData = data;
            } catch (error) {
                console.error('Error loading locations:', error);
                regionData = {};
            }
        }

        async function performWrite(renderResults = true) {
            writeButton.disabled = true;
            const regions = ['wnam', 'enam', 'weur', 'eeur', 'apac', 'oc'];
            lastWriteTime = new Date();
            lastWrite.textContent = `Last write: ${lastWriteTime.toLocaleTimeString()}`;

            try {
                // First get the nearest region
                const nearestResponse = await fetch(`${API_BASE}`, {
                    method: 'POST',
                    mode: 'cors',
                    headers: {
                        'Accept': '*/*',
                        'Content-Type': 'application/json',
                    },
                    credentials: 'omit',
                    body: JSON.stringify({ region: 'nearest' })
                });
                
                if (!nearestResponse.ok) throw new Error('Network response was not ok for nearest');
                const nearestData = await nearestResponse.json();
                const nearestResult = {
                    region: 'NEAREST',
                    latency: nearestData.ping,
                    colo: nearestData.colo
                };

                // Then get all other regions
                const requests = regions.map(region => {
                    const startTime = performance.now();
                    return fetch(`${API_BASE}`, {
                        method: 'POST',
                        mode: 'cors',
                        headers: {
                            'Accept': '*/*',
                            'Content-Type': 'application/json',
                        },
                        credentials: 'omit',
                        body: JSON.stringify({ region })
                    })
                    .then(async response => {
                        const endTime = performance.now();
                        if (!response.ok) throw new Error(`Network response was not ok for ${region}`);
                        const data = await response.json();
                        const latency = data.ping;
                        
                        if (!latencyHistory[data.colo]) {
                            latencyHistory[data.colo] = [];
                        }
                        latencyHistory[data.colo].push(latency);
                        
                        return {
                            region: region.toUpperCase(),
                            latency: latency,
                            colo: data.colo
                        };
                    });
                });

                const results = await Promise.all(requests);
                // Filter out any region that matches the nearest region's colo
                const filteredResults = results.filter(result => result.colo !== nearestResult.colo);
                window.latencyResults = [nearestResult, ...filteredResults];
                if (renderResults) {
                    updateCards();
                    updateTimeSavings(results);
                }
            } catch (error) {
                console.error('Error performing writes:', error);
            } finally {
                writeButton.disabled = false;
            }
        }

        function calculateStats(latencies) {
            if (!latencies || latencies.length === 0) return { mean: '-', median: '-', min: '-', max: '-' };
            
            const mean = Math.round(latencies.reduce((a, b) => a + b, 0) / latencies.length);
            const sorted = [...latencies].sort((a, b) => a - b);
            const median = Math.round(sorted[Math.floor(sorted.length / 2)]);
            const min = Math.min(...latencies);
            const max = Math.max(...latencies);
            
            return { mean, median, min, max };
        }

        function calculateStability(latencies) {
            if (!latencies || latencies.length < 2) return { level: 'unknown', cv: 0 };
            
            const mean = latencies.reduce((a, b) => a + b, 0) / latencies.length;
            const variance = latencies.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / latencies.length;
            const stdDev = Math.sqrt(variance);
            const cv = stdDev / mean;
            
            if (cv < 0.1) return { level: 'high', cv };
            if (cv < 0.2) return { level: 'medium', cv };
            return { level: 'low', cv };
        }

        function getLatencyClass(value) {
            if (value === '-') return '';
            if (value < 100) return 'latency-good';
            if (value < 200) return 'latency-medium';
            return 'latency-poor';
        }

        // Initialize mobile globe and pre-render all region views
        async function initializeMobileGlobes() {
            if (!mobileGlobeInstance) {
                const container = document.createElement('div');
                mobileGlobeInstance = new Globe(container, 160, 80);
                mobileGlobeInstance.stopAnimation(); // Stop animation immediately
                
                // Wait for texture to load
                await new Promise(resolve => {
                    const checkTexture = () => {
                        if (mobileGlobeInstance.texture) {
                            resolve();
                        } else {
                            setTimeout(checkTexture, 50);
                        }
                    };
                    checkTexture();
                });
                
                // Pre-render each region's view
                const regionAngles = {
                    'wnam': { x: -Math.PI / 2.2, y: Math.PI * 1.15 + Math.PI / 2 },
                    'enam': { x: -Math.PI / 2.2, y: Math.PI * 1.15 + Math.PI },
                    'weur': { x: -Math.PI / 2.2, y: Math.PI * 1.15 + Math.PI * 1.5 },
                    'eeur': { x: -Math.PI / 2.2, y: Math.PI * 1.15 + Math.PI * 2 },
                    'apac': { x: -Math.PI / 2.2, y: Math.PI * 1.15 + Math.PI * 2.5 },
                    'oc': { x: -Math.PI / 2.2, y: Math.PI * 1.15 + Math.PI * 3 }
                };

                // Generate and store ASCII for each region
                Object.entries(regionAngles).forEach(([region, angles]) => {
                    mobileGlobeInstance.angleX = angles.x;
                    mobileGlobeInstance.angleY = angles.y;
                    mobileGlobeInstance.angleZ = 0;
                    const ascii = mobileGlobeInstance.render();
                    regionGlobeViews[region] = `<pre>${ascii}</pre>`;
                });
            }
        }

        function wrapInFlip(newValue, previousValue, unit = '') {
            if (newValue === '-') return '-';
            return `<span class="flip-number">${
                newValue.toString()
                    .split('')
                    .map((digit, i) => {
                        const previousDigit = previousValue.toString()[i];
                        const shouldAnimate = previousDigit !== digit;
                        return `<span class="flip-digit${shouldAnimate ? ' updating' : ''}" style="animation-delay: ${i * 0.1}s">${digit}</span>`;
                    })
                    .join('')
            }</span>${unit}`;
        }

        async function updateCards() {
            const results = window.latencyResults || [];
            
            // Initialize globes if needed
            if (!globeInstance) {
                globeInstance = new Globe(globeContainer, 160, 80);
                globeInstance.angleX = -Math.PI / 2.2;
                globeInstance.angleY = Math.PI * 1.15;
                globeInstance.angleZ = 0;
                globeInstance.render();
            }
            
            // Initialize mobile globes if needed
            await initializeMobileGlobes();
            
            // Remove loading class from globe container
            if (globeContainer) {
                globeContainer.classList.remove('loading');
            }
            
            // Find the slowest region (excluding nearest)
            const nonNearestResults = results.filter(r => r.region !== 'NEAREST');
            const slowestLatency = Math.max(...nonNearestResults.map(r => r.latency));
            
            // Get previous values for animation
            const previousCards = Array.from(regionsList.querySelectorAll('.region-card')).map(card => ({
                colo: card.querySelector('.region-code').textContent,
                latency: card.querySelector('.stat-value').textContent.replace(' ms', '')
            }));
            
            regionsList.innerHTML = results.map(result => {
                const location = regionData.find(loc => loc.iata === result.colo);
                const locationName = location ? `${location.city}, ${location.cca2}, ${location.region}` : result.colo;
                const isNearest = result.region === 'NEAREST';
                const regionKey = result.region.toLowerCase();
                const previousValue = previousCards.find(card => card.colo === result.colo)?.latency || result.latency;

                return `
                    <div class="region-card ${isNearest ? 'fastest' : ''}" 
                         data-region="${regionKey}"
                         onmouseenter="handleCardHover('${regionKey}')">
                        <div class="card-header">
                            <span class="region-code">${result.colo}</span>
                            <h3>${locationName}</h3>
                        </div>
                        <div class="card-stats">
                            <div class="stat">
                                <span class="stat-label">Ping</span>
                                <span class="stat-value ${isNearest ? 'latency-good' : ''}">
                                    ${wrapInFlip(result.latency, previousValue, ' ms')}
                                </span>
                            </div>
                        </div>
                        <div class="mobile-globe">
                            ${regionGlobeViews[regionKey] || ''}
                        </div>
                    </div>
                `;
            }).join('');

            // Remove animation class after animation completes
            document.querySelectorAll('.flip-digit.updating').forEach(el => {
                el.addEventListener('animationend', () => {
                    el.classList.remove('updating');
                }, { once: true });
            });

            // Update time savings with the slowest region
            updateTimeSavings(results, slowestLatency);
        }

        // Handle card hover to rotate globe
        window.handleCardHover = function(region) {
            if (globeInstance && region !== currentRegion) {
                currentRegion = region;
                
                const regionAngles = {
                    'wnam': { x: -Math.PI / 2.2, y: Math.PI * 1.15 + Math.PI / 2 },
                    'enam': { x: -Math.PI / 2.2, y: Math.PI * 1.15 + Math.PI },
                    'weur': { x: -Math.PI / 2.2, y: Math.PI * 1.15 + Math.PI * 1.5 },
                    'eeur': { x: -Math.PI / 2.2, y: Math.PI * 1.15 + Math.PI * 2 },
                    'apac': { x: -Math.PI / 2.2, y: Math.PI * 1.15 + Math.PI * 2.5 },
                    'oc': { x: -Math.PI / 2.2, y: Math.PI * 1.15 + Math.PI * 3 }
                };

                const angles = regionAngles[region];
                if (angles) {
                    globeInstance.setTargetRotation(angles.x, angles.y);
                }
            }
        };

        // Add mouseout handler to reset current region when not hovering any card
        document.addEventListener('DOMContentLoaded', () => {
            const regionsList = document.getElementById('regionsList');
            regionsList.addEventListener('mouseleave', () => {
                currentRegion = null;
                if (globeInstance) {
                    globeInstance.setTargetRotation(-Math.PI / 2.2, Math.PI * 1.15);
                }
            });
        });

        // Function to update time savings display
        function updateTimeSavings(results, slowestLatency) {
            if (!results || results.length === 0) return;
            
            // Find slowest non-nearest region
            const nonNearestResults = results.filter(r => r.region !== 'NEAREST');
            const slowestResult = nonNearestResults.reduce((slowest, current) => 
                current.latency > slowest.latency ? current : slowest
            );
            
            // Get location info for slowest region
            const slowestLocation = regionData.find(loc => loc.iata === slowestResult.colo);
            const locationName = slowestLocation ? 
                `${slowestLocation.city}, ${slowestLocation.cca2}` : 
                slowestResult.colo;
            
            // Calculate time savings
            const nearestResult = results.find(r => r.region === 'NEAREST');
            const savings = slowestResult.latency - nearestResult.latency;
            
            // Update the display
            const savingsElement = document.querySelector('.savings-value');
            const slowestLatencyElement = document.querySelector('.slowest-latency');
            const slowestLocationElement = document.querySelector('.slowest-location');
            const timeSavingsElement = document.querySelector('.time-savings');
            
            if (savingsElement && slowestLatencyElement && slowestLocationElement) {
                savingsElement.textContent = `${savings}ms`;
                slowestLatencyElement.textContent = slowestResult.latency;
                slowestLocationElement.textContent = locationName;
                
                // Show the element with animation
                timeSavingsElement.classList.add('visible');
            }
        }

        // Initialize
        loadLocations().then(async () => {
            writeButton.addEventListener('click', () => performWrite(true));
            latencyHistory = {};
            
            // Show loading state
            showLoadingState();
            
            // Do a warm-up call first
            await performWrite(false);
            
            // Then show the results from the second call
            await performWrite(true);
            
            // Set up automatic refresh every 5 seconds
            updateInterval = setInterval(() => {
                performWrite(true);
            }, 5000);
        });

        function showLoadingState() {
            const regions = ['wnam', 'enam', 'weur', 'eeur', 'apac', 'oc'];
            regionsList.innerHTML = regions.map(region => `
                <div class="region-card loading" data-region="${region}">
                    <div class="card-header">
                        <span class="region-code"></span>
                        <h3></h3>
                    </div>
                    <div class="card-stats">
                        <div class="stat">
                            <span class="stat-label"></span>
                            <span class="stat-value"></span>
                        </div>
                    </div>
                    <div class="mobile-globe"></div>
                </div>
            `).join('');

            // Add loading class to globe container
            if (globeContainer) {
                globeContainer.classList.add('loading');
            }
        }

        // Cleanup interval when page unloads
        window.addEventListener('unload', () => {
            if (updateInterval) {
                clearInterval(updateInterval);
            }
        });
    </script>
</body>
</html> 