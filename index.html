<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>D1 Read Replicas - Cloudflare</title>
    <link rel="stylesheet" href="global.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
</head>
<body>
    <header class="header">
        <div class="logo">
            <img src="cloudflare.svg" alt="Cloudflare">
        </div>
        <!-- <div class="auth-buttons">
            <button class="sign-in">Sign In</button>
            <button class="sign-up">Sign Up</button>
        </div> -->
    </header>

    <main class="main-content">
        <div class="breadcrumb">Introducing</div>
        <h1>D1 Read Replicas</h1>
        <p class="description">
            Watch how quickly writes propagate across our global network of read replicas. 
            Click the button below to perform a write operation and observe the latency across different regions.
        </p>
        
        <div class="controls">
            <button class="write-button" id="writeButton">Perform Write</button>
            <!-- <span class="last-write" id="lastWrite"></span> -->
        </div>

        <table>
            <thead>
                <tr>
                    <th class="title-col">Region</th>
                    <th>Code</th>
                    <th>Mean</th>
                    <th>Median</th>
                    <th>Min</th>
                    <th>Max</th>
                    <th>Latest</th>
                </tr>
            </thead>
            <tbody id="replicaTable">
                <!-- Table rows will be populated by JavaScript -->
            </tbody>
        </table>
    </main>

    <!-- <div id="globe-container"></div> -->
    <script type="module" src="js/main.js"></script>
    <script>
        const API_BASE = 'https://replication-regions.brayden-b8b.workers.dev';
        const writeButton = document.getElementById('writeButton');
        const lastWrite = document.getElementById('lastWrite');
        const replicaTable = document.getElementById('replicaTable');
        let lastWriteTime = null;
        let regionData = {};
        // Add storage for historical latency values
        let latencyHistory = {};

        // Fetch locations data
        async function loadLocations() {
            try {
                const response = await fetch('/locations.json');
                const data = await response.json();
                regionData = data;
            } catch (error) {
                console.error('Error loading locations:', error);
                // Fallback to existing mapping if load fails
                regionData = {};
            }
        }

        async function performWrite(renderResults = true) {
            writeButton.disabled = true;
            const regions = ['wnam', 'enam', 'weur', 'eeur', 'apac', 'oc'];
            lastWriteTime = new Date();
            // lastWrite.textContent = `Last write: ${lastWriteTime.toLocaleTimeString()}`;

            try {
                const requests = regions.map(region => {
                    const startTime = performance.now();
                    return fetch(`${API_BASE}`, {
                        method: 'POST',
                        mode: 'cors',
                        headers: {
                            'Accept': '*/*',
                            'Content-Type': 'application/json',
                        },
                        credentials: 'omit',
                        body: JSON.stringify({ region })
                    })
                    .then(async response => {
                        const endTime = performance.now();
                        if (!response.ok) throw new Error(`Network response was not ok for ${region}`);
                        const data = await response.json();
                        const latency = Math.round(endTime - startTime - data.subtract);
                        
                        // Store latency in history
                        if (!latencyHistory[data.colo]) {
                            latencyHistory[data.colo] = [];
                        }
                        latencyHistory[data.colo].push(latency);
                        
                        return {
                            region: region.toUpperCase(),
                            latency: latency,
                            colo: data.colo
                        };
                    });
                });

                const results = await Promise.all(requests);
                window.latencyResults = results;
                if (renderResults) {
                    updateTable();
                }
            } catch (error) {
                console.error('Error performing writes:', error);
            } finally {
                writeButton.disabled = false;
            }
        }

        function calculateStats(latencies) {
            if (!latencies || latencies.length === 0) return { mean: '-', median: '-', min: '-', max: '-' };
            
            const mean = Math.round(latencies.reduce((a, b) => a + b, 0) / latencies.length);
            const sorted = [...latencies].sort((a, b) => a - b);
            const median = Math.round(sorted[Math.floor(sorted.length / 2)]);
            const min = Math.min(...latencies);
            const max = Math.max(...latencies);
            
            return { mean, median, min, max };
        }

        function getLatencyClass(value) {
            if (value === '-') return '';
            if (value < 100) return 'latency-good';
            if (value < 200) return 'latency-medium';
            return 'latency-poor';
        }

        function updateTable() {
            const results = window.latencyResults || [];
            console.log('regionData:', regionData);
            console.log('results:', results);
            replicaTable.innerHTML = results.map(result => {
                const location = regionData.find(loc => loc.iata === result.colo);
                const locationName = location ? `${location.city}, ${location.cca2}, ${location.region}` : result.colo;
                
                const stats = calculateStats(latencyHistory[result.colo]);
                
                const wrapInFlip = (value, unit = '') => {
                    if (value === '-') return '-';
                    return `<span class="flip-number">${
                        value.toString()
                            .split('')
                            .map((digit, i) => `<span class="flip-digit" style="animation-delay: ${i * 0.1}s">${digit}</span>`)
                            .join('')
                    }</span>${unit}`;
                };

                return `
                    <tr>
                        <td class="title-col">${locationName}</td>
                        <td class="region-code">${result.colo}</td>
                        <td class="normal-col ${getLatencyClass(stats.mean)}">${wrapInFlip(stats.mean, ' ms')}</td>
                        <td class="normal-col ${getLatencyClass(stats.median)}">${wrapInFlip(stats.median, ' ms')}</td>
                        <td class="normal-col ${getLatencyClass(stats.min)}">${wrapInFlip(stats.min, ' ms')}</td>
                        <td class="normal-col ${getLatencyClass(stats.max)}">${wrapInFlip(stats.max, ' ms')}</td>
                        <td class="normal-col ${getLatencyClass(result.latency)}">${wrapInFlip(result.latency, ' ms')}</td>
                    </tr>
                `;
            }).join('');

            // Add animation class to new numbers
            document.querySelectorAll('.flip-digit').forEach(el => {
                el.classList.add('updating');
                el.addEventListener('animationend', () => {
                    el.classList.remove('updating');
                }, { once: true });
            });
        }

        // Initialize
        loadLocations().then(async () => {
            writeButton.addEventListener('click', () => performWrite(true));
            // Perform a warm-up write without recording data or rendering
            latencyHistory = {}; // Clear any existing history
            await performWrite(false);
            // Small delay before the actual first write
            setTimeout(() => {
                latencyHistory = {}; // Reset history before the real measurement
                performWrite(true);
            }, 100);
        });
    </script>
</body>
</html> 